// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "./../Common.hpp"
#include "./../Network.hpp"

#include <thread>
#include <mutex>
#include <atomic>


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx { namespace utl
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Thread context.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	SX_META struct ThreadCtx
	{
		std::mutex Lock;
		sx::Network<T> Net;
		uMAX Id;
		uMAX SamplesOffBeg;
		uMAX SamplesOffCur;
		std::atomic<uMAX> Epoch;
		std::atomic<uMAX> SamplesNotCommited;

		ThreadCtx ( void ) :
		Id(0),
		SamplesOffBeg(0),
		SamplesOffCur(0),
		Epoch(0),
		SamplesNotCommited(0){}
	};
	
	
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Basic multi threaded trainer.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	SX_META class MtTrainer
	{
		private:
		
		// Data.
		const Samples<T>* Input;
		const Samples<T>* Output;
		fn<void(sx::Network<T>&)> NetBuildFunc;
		const uMAX ThreadsCount;
		vec<ThreadCtx<T>> ThreadsCtx;


		public:

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// 
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto thread ( void )
		{
		}


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// 
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		MtTrainer ( const Samples<T>& _In, const Samples<T>& _Out, fn<void(sx::Network<T>&)> _NetBuilder, const uMAX _ThreadsCount = 3 )
		:
			Input(&_In),
			Output(&_Out),
			NetBuildFunc(_NetBuilder),
			ThreadsCount(_ThreadsCount)
		{}


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// 
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto launch ( void )
		{
			this->ThreadsCtx = vec<ThreadCtx>(this->ThreadsCount);
			
			for(auto t = uMAX(0); t < this->ThreadsCount; ++t)
			{
				this->ThreadsCtx[t].Id = t;
				this->ThreadsCtx[t].SamplesOffBeg = (this->Input->size() / this->ThreadsCount) * t;
			

				//createNetwork(ThreadContexts[t].NetDeltaWave, 0);
				//ThreadContexts[t].NetDeltaWave.front()->exchange(NetDeltaWave.front());


				//ThreadHandles.push_back(std::thread(trainThread, &ThreadContexts[t]));
			}
		}

	};


	/*

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Training thread's context.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T = r32> struct SamplesSet
	{
		vec<vec<T>>* Input;
		vec<vec<T>>* Output;
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Training thread's context.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T = r32> struct TContext
	{
		std::mutex Lock;
		sx::Network<T> Net;
		uMAX Id;
		uMAX SamplesOffBeg;
		uMAX SamplesOffCur;
		std::atomic<uMAX> Epoch;
		std::atomic<uMAX> SamplesNotCommited;

		TContext ( void ) :
		Id(0),
		SamplesOffBeg(0),
		SamplesOffCur(0),
		Epoch(0),
		SamplesNotCommited(0){}
	};


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	auto ThreadCount = std::thread::hardware_concurrency()-1;
	auto Batch = uMAX(8);
	auto Rate = rMAX(0.0002);
	auto Samples = SamplesSet();



	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Training thread.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T = r32> auto thread ( TContext<T>* _Context )
	{
		while(true)
		{
			_Context->Lock.lock();


			auto SampleIdx = _Context->SamplesOffBeg + _Context->SamplesOffCur;
			
			const auto SampleIn = SamplesIn[SampleIdx].data();
			const auto SampleOut = SamplesOut[SampleIdx].data();


			_Context->NetDeltaWave.exe(SampleIn);
			_Context->NetDeltaWave.fit(SampleOut, 1.0);


			_Context->SamplesNotCommited++;

			_Context->SamplesOffCur++;

			
			if(_Context->SamplesOffCur >= ((SamplesIn.size()-1) / cfg::THREADS))
			{
				_Context->Epoch++;
				_Context->SamplesOffCur = 0;
			}
	
			
			_Context->Lock.unlock();
		}
	}


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Launch training threads.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T = r32> auto launch ( void )
	{
		ThreadContexts = std::vector<ThreadContext>(cfg::THREADS);
		for(auto t = uMAX(0); t < cfg::THREADS; ++t)
		{
			ThreadContexts[t].Id = t;
			ThreadContexts[t].SamplesOffBeg = (SamplesIn.size() / cfg::THREADS) * t;
			

			createNetwork(ThreadContexts[t].NetDeltaWave, 0);
			ThreadContexts[t].NetDeltaWave.front()->exchange(NetDeltaWave.front());


			ThreadHandles.push_back(std::thread(trainThread, &ThreadContexts[t]));
		}
	}
	*/
}}
