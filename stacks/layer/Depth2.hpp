// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Convolutional layer 2d.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		uMAX WIDTH_IN,
		uMAX HEIGHT_IN,
		uMAX DEPTH_IN,
		uMAX DEPTH_OUT,
		class FN_TRANS = FnTrRelu<T>,
		bool USE_BIASES = true,
		FnOptim FN_OPTIM = FnOptim::ADAM
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Depth2 :
		public Layer<T>,
		LDWeights<T, FN_OPTIM, DEPTH_IN*DEPTH_OUT, WIDTH_IN*HEIGHT_IN*DEPTH_IN, WIDTH_IN*HEIGHT_IN*DEPTH_OUT, FnInitWeights::DEFAULT>,
		LDBiases<T, WIDTH_IN*HEIGHT_IN*DEPTH_OUT, 0, 0, FN_OPTIM>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto SZ_BUF_W = DEPTH_IN*DEPTH_OUT;
		constexpr static auto SZ_BUF_B = WIDTH_IN * HEIGHT_IN * DEPTH_OUT;
		constexpr static auto SZ_IN = WIDTH_IN * HEIGHT_IN * DEPTH_IN;
		constexpr static auto SZ_OUT = WIDTH_IN * HEIGHT_IN * DEPTH_OUT;
		

		alignas(ALIGNMENT) T OutTrans[SZ_OUT];
		alignas(ALIGNMENT) T OutTemp[SZ_OUT];
		alignas(ALIGNMENT) T Gradient[SZ_IN];

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Depth2, SZ_OUT, this->OutTrans, this->Gradient)


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			memZero(SZ_OUT, this->OutTemp);


			for(auto lo = uMAX(0); lo < DEPTH_OUT; ++lo)
			{ 
				auto CurWeights = this->Weights + math::index_c(0, lo, DEPTH_IN);

				for(auto li = uMAX(0); li < DEPTH_IN; ++li)
				{
					for(auto y = 0; y < HEIGHT_IN; ++y)
					{
						const auto IdxOut = math::index_c(0, y, lo, WIDTH_IN, HEIGHT_IN);
						const auto IdxIn = math::index_c(0, y, li, WIDTH_IN, HEIGHT_IN);
						
						for(auto x = 0; x < WIDTH_IN; ++x) this->OutTemp[IdxOut+x] += this->Input[IdxIn+x] * CurWeights[li];
					}
				}
			}


			for(auto o = uMAX(0); o < (WIDTH_IN * HEIGHT_IN * DEPTH_OUT); ++o)
			{
				if constexpr(USE_BIASES) this->OutTemp[o] += this->Biases[o];
				this->OutTrans[o] = FN_TRANS::trans(this->OutTemp[o]);
			}


			SX_MC_LAYER_NEXT_EXE;
		}


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate. Optimized for memory order.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			memZero(SZ_IN, this->Gradient);


			if(!this->IsLocked)
			{
				T DerTrans[WIDTH_IN*HEIGHT_IN];
				auto PtrFrontGradient = this->Front->gradient();
				auto PtrTrDerSrc = this->OutTemp;
				if constexpr(!FN_TRANS::RAW) PtrTrDerSrc = this->OutTrans;
				

				for(auto lo = uMAX(0); lo < DEPTH_OUT; ++lo)
				{ 
					auto CurWeights = this->Weights + math::index_c(0, lo, DEPTH_IN);
					auto CurWeightsDlt = this->WeightsDlt + math::index_c(0, lo, DEPTH_IN);


					const auto OffOut = math::index_c(0, 0, lo, WIDTH_IN, HEIGHT_IN);
					auto LineOutUn = PtrTrDerSrc + OffOut;
					memCopy(WIDTH_IN*HEIGHT_IN, DerTrans, PtrFrontGradient + OffOut);
					for(auto o = 0; o < WIDTH_IN*HEIGHT_IN; ++o) DerTrans[o] *= FN_TRANS::der(LineOutUn[o]);;

					for(auto li = uMAX(0); li < DEPTH_IN; ++li)
					{
						for(auto y = 0; y < HEIGHT_IN; ++y) { for(auto x = 0; x < WIDTH_IN; ++x)
						{
							const auto IdxIn = math::index_c(x, y, li, WIDTH_IN, HEIGHT_IN);
							const auto IdxDer = math::index_c(x, y, WIDTH_IN);

							CurWeightsDlt[li] += this->Input[IdxIn] * DerTrans[IdxDer];
							this->Gradient[IdxIn] += CurWeights[li] * DerTrans[IdxDer];
						}}
					}
				}
				

				if constexpr(USE_BIASES)
				{
					auto OutNeeded = this->OutTrans;
					if constexpr(FN_TRANS::RAW) OutNeeded = this->OutTemp;

					for(auto o = uMAX(0); o < (WIDTH_IN * HEIGHT_IN * DEPTH_OUT); ++o)
					{
						const auto DerErr = this->Front->gradient()[o];
						const auto DerTrans = FN_TRANS::der(OutNeeded[o]) * DerErr;
						this->BiasesDlt[o] += DerTrans;
					}
				}
			}

			else
			{
			
			}

			SX_MC_LAYER_NEXT_FIT;
		}


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get output error in respect to argument.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Reset delta parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplReset.hpp"


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply optimizations and update parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplApply.hpp"


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Store parameters to stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplStore.hpp"


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Load parameters from stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplLoad.hpp"


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Multi threading utility.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplExchange.hpp"
	};
}
