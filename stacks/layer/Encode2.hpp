// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "./../Layer.hpp"

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Feature encoder 2d.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		uMAX SZ_WIDTH_IN,
		uMAX SZ_HEIGHT_IN,
		uMAX SZ_TILE = 8,
		FnTrans FN_TRANS = FnTrans::RELU,
		FnInitWeights FN_INIT_W = FnInitWeights::NRM_RELU,
		FnOptim FN_OPTIM = FnOptim::ADAM
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Encode2 :
		public Layer<T>,
		LDOutputs<T, (SZ_WIDTH_IN/SZ_TILE)*(SZ_HEIGHT_IN/SZ_TILE), SZ_WIDTH_IN*SZ_HEIGHT_IN, true>,
		LDWeights<T, FN_OPTIM, SZ_WIDTH_IN*SZ_HEIGHT_IN, SZ_WIDTH_IN*SZ_HEIGHT_IN, (SZ_WIDTH_IN/SZ_TILE)*(SZ_HEIGHT_IN/SZ_TILE), FN_INIT_W>,
		LDBiases<T, (SZ_WIDTH_IN/SZ_TILE)*(SZ_HEIGHT_IN/SZ_TILE), SZ_WIDTH_IN*SZ_HEIGHT_IN, (SZ_WIDTH_IN/SZ_TILE)*(SZ_HEIGHT_IN/SZ_TILE), needBufM<T,FN_OPTIM>(), needBufV<T,FN_OPTIM>()>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto SZ_TILES_X = (SZ_WIDTH_IN / SZ_TILE);
		constexpr static auto SZ_TILES_Y = (SZ_HEIGHT_IN / SZ_TILE);
		constexpr static auto SZ_IN = SZ_WIDTH_IN * SZ_HEIGHT_IN;
		constexpr static auto SZ_OUT = (SZ_WIDTH_IN / SZ_TILE) * (SZ_HEIGHT_IN / SZ_TILE);
		constexpr static auto SZ_BUF_W = SZ_IN;
		constexpr static auto SZ_BUF_B = SZ_OUT;

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Encode2, SZ_OUT, this->OutTrans, this->Gradient)

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Members.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		alignas(ALIGNMENT) T InputWeighted[SZ_IN];
		alignas(ALIGNMENT) T Derivatives[SZ_OUT];

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute. Optimized for sequential access.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			memZero(SZ_OUT, this->OutRaw);


			vops::mulVecByVec(SZ_IN, this->InputWeighted, this->Input, this->Weights);


			auto PtrOutRw = this->OutRaw;
			auto PtrInWgh = this->InputWeighted;
			for(auto y = uMAX(0); y < SZ_HEIGHT_IN ; y += SZ_TILE)
			{
				for(auto yt = uMAX(0); yt < SZ_TILE; ++yt)
				{
					for(auto x = uMAX(0); x < SZ_WIDTH_IN ; x += SZ_TILE)
					{
						for(auto xt = uMAX(0); xt < SZ_TILE; ++xt)
						{
							(*PtrOutRw) += PtrInWgh[x+xt];
						}

						PtrOutRw++;
					}

					PtrOutRw -= SZ_TILES_X;
					PtrInWgh += SZ_WIDTH_IN;
				}

				PtrOutRw += SZ_TILES_X;
			}


			for(auto o = uMAX(0); o < SZ_OUT; ++o) this->OutRaw[o] += this->Biases[o];
			for(auto o = uMAX(0); o < SZ_OUT; ++o) this->OutTrans[o] = transfer<T,FN_TRANS>(this->OutRaw[o]);


			SX_MC_LAYER_NEXT_EXE;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate. Optimized for memory order.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			memZero(SZ_IN, this->Gradient);


			auto PtrFrGrad = this->Front->gradient();
			auto PtrTrDerSrc = this->OutRaw;
			if constexpr(!needRaw<T,FN_TRANS>()) PtrTrDerSrc = this->OutTrans;
			for(auto o = uMAX(0); o < SZ_OUT; ++o)
			{
				this->Derivatives[o] = transferDer<T,FN_TRANS>(PtrTrDerSrc[o]) * PtrFrGrad[o];
				this->BiasesDlt[o] += this->Derivatives[o];
			}


			auto PtrGrad = this->Gradient;
			auto PtrInput = this->Input;
			auto PtrWght = this->Weights;
			auto PtrWghtDlt = this->WeightsDlt;
			auto ox = uMAX(0);
			auto oy = uMAX(0);
			for(auto y = uMAX(0); y < SZ_HEIGHT_IN ; y += SZ_TILE)
			{
				for(auto yt = uMAX(0); yt < SZ_TILE; ++yt)
				{
					for(auto x = uMAX(0); x < SZ_WIDTH_IN ; x += SZ_TILE)
					{
						const auto IdxDer = math::index_c(ox, oy, SZ_WIDTH_IN);
						for(auto xt = uMAX(0); xt < SZ_TILE; ++xt)
						{
							(*PtrGrad) += PtrWght[x+xt] * this->Derivatives[IdxDer];
							(*PtrWghtDlt) += PtrInput[x+xt] * this->Derivatives[IdxDer];
						}

						ox++;
					}

					ox -= SZ_TILES_X;
					PtrGrad += SZ_WIDTH_IN;
					PtrInput += SZ_WIDTH_IN;
					PtrWght += SZ_WIDTH_IN;
					PtrWghtDlt += SZ_WIDTH_IN;
				}

				oy++;
			}


			SX_MC_LAYER_NEXT_FIT;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get output error in respect to argument.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Reset delta parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplReset.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply optimizations and update parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplApply.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Store parameters to stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplStore.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Load parameters from stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplLoad.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Multi threading utility.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplExchange.hpp"
	};
}
