// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "./../Layer.hpp"

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Convolutional layer 2d.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		uMAX WIDTH_IN,
		uMAX HEIGHT_IN,
		uMAX DEPTH_IN,
		uMAX KERNELS = 1,
		uMAX RADIUS = 1,
		FnTrans FN_TRANS = FnTrans::PRELU,
		FnOptim FN_OPTIM = FnOptim::MOMENTUM,
		FnErr FN_ERR = FnErr::MSE
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Conv2 :
		public Layer<T>,
		LDOutputs<T, WIDTH_IN * HEIGHT_IN * KERNELS, WIDTH_IN * HEIGHT_IN * DEPTH_IN, true>,
		LDWeights<T, uMAX(((RADIUS*2)+1)*((RADIUS*2)+1)) * KERNELS * DEPTH_IN, 0, 0, needBufM<T,FN_OPTIM>(), needBufV<T,FN_OPTIM>()>,
		LDBiases<T, WIDTH_IN * HEIGHT_IN * KERNELS, 0, 0, needBufM<T,FN_OPTIM>(), needBufV<T,FN_OPTIM>()>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto SZ_KER_EDGE = uMAX(RADIUS * 2 + 1);
		constexpr static auto SZ_KER = SZ_KER_EDGE * SZ_KER_EDGE;
		constexpr static auto SZ_KER_RDX_MIN = -iMAX(RADIUS);
		constexpr static auto SZ_KER_RDX_MAX = iMAX(RADIUS + 1);

		constexpr static auto SZ_BUF_W = SZ_KER * KERNELS * DEPTH_IN;
		constexpr static auto SZ_BUF_B = WIDTH_IN * HEIGHT_IN * KERNELS;
		constexpr static auto SZ_IN = WIDTH_IN * HEIGHT_IN * DEPTH_IN;
		constexpr static auto SZ_OUT = WIDTH_IN * HEIGHT_IN * KERNELS;
		
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Conv2, SZ_OUT, this->OutTrans, this->Gradient)

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute layer.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			memZero(SZ_OUT, this->OutRaw);

			for(auto k = uMAX(0); k < KERNELS; ++k) { for(auto d = u64(0); d < DEPTH_IN; ++d) { for(auto y = RADIUS; y < (HEIGHT_IN - RADIUS); ++y)
			{
				auto ky = SZ_KER_RDX_MIN;
				auto wo = uMAX(0);
				for(auto kr = uMAX(0); kr < SZ_KER_EDGE; ++kr)
				{
					for(auto x = RADIUS; x < (WIDTH_IN - RADIUS); ++x)
					{
						const auto o = math::index_c(x, y, k, WIDTH_IN, HEIGHT_IN);
						auto w = wo;
						for(auto kx = SZ_KER_RDX_MIN; kx != SZ_KER_RDX_MAX; ++kx)
						{
							this->OutRaw[o] += this->Input[math::index_c(x+kx, y+ky, d, WIDTH_IN, HEIGHT_IN)] * this->Weights[math::index_c(w, k, SZ_KER)];
							++w;
						}
					}

					ky += 1;
					wo += SZ_KER_EDGE;
				}
			}}}

			for(auto o = uMAX(0); o < SZ_OUT; ++o) this->OutTrans[o] = transfer<T,FN_TRANS>(this->OutRaw[o] + this->Biases[o]);

			SX_MC_LAYER_NEXT_EXE;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			memZero(SZ_IN, this->Gradient);

			for(auto k = uMAX(0); k < KERNELS; ++k) { for(auto d = u64(0); d < DEPTH_IN; ++d) { for(auto y = RADIUS; y < (HEIGHT_IN - RADIUS); ++y)
			{
				auto ky = SZ_KER_RDX_MIN;
				auto wo = uMAX(0);
				for(auto kr = uMAX(0); kr < SZ_KER_EDGE; ++kr)
				{
					for(auto x = RADIUS; x < (WIDTH_IN - RADIUS); ++x)
					{
						const auto o = math::index_c(x, y, k, WIDTH_IN, HEIGHT_IN);
						SX_MC_LAYER_DER_ERR;
						SX_MC_LAYER_DER_TRANS;
						auto w = wo;
						for(auto kx = SZ_KER_RDX_MIN; kx != SZ_KER_RDX_MAX; ++kx)
						{
							const auto i = math::index_c(x+kx, y+ky, d, WIDTH_IN, HEIGHT_IN);
							const auto ow = math::index_c(w, k, SZ_KER);
							
							if(!this->IsLocked) this->WeightsDlt[ow] += (this->Input[i] * DerTrans);
							this->Gradient[i] += (this->Weights[ow] * DerTrans);
							
							++w;
						}

						this->BiasesDlt[o] += DerTrans;
					}

					ky += 1;
					wo += SZ_KER_EDGE;
				}
			}}}

			SX_MC_LAYER_NEXT_FIT;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get error between target and output.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Reset deltas.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplReset.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply optimizations and update parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplApply.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Store parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplStore.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Load parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplLoad.hpp"
	};
}
