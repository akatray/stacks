// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "./../Layer.hpp"

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Upscale layer 2d.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		uMAX WIDTH_IN,
		uMAX HEIGHT_IN,
		uMAX DEPTH_IN,
		FnErr FN_ERR = FnErr::MSE
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Upscale2 :
		public Layer<T>,
		LDOutputs<T, (WIDTH_IN * 2) * (HEIGHT_IN * 2) * DEPTH_IN, WIDTH_IN * HEIGHT_IN * DEPTH_IN, false>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto WIDTH_OUT = WIDTH_IN * 2;
		constexpr static auto HEIGHT_OUT = HEIGHT_IN * 2;
		constexpr static auto SZ_IN = WIDTH_IN * HEIGHT_IN * DEPTH_IN;
		constexpr static auto SZ_OUT = WIDTH_OUT * HEIGHT_OUT * DEPTH_IN;
		
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Upscale2, SZ_OUT, this->OutTrans, this->Gradient)

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute layer.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			auto ox = uMAX(0);
			auto oy = uMAX(0);

			for(auto iy = uMAX(0); iy < HEIGHT_IN; ++iy) { for(auto ix = uMAX(0); ix < WIDTH_IN; ++ix)
			{
				for(auto d = u64(0); d < DEPTH_IN; ++d)
				{
					const auto Value = this->Input[math::index_c(ix, iy, d, WIDTH_IN, HEIGHT_IN)];

					this->OutTrans[math::index_c(ox, oy, d, WIDTH_OUT, HEIGHT_OUT)] = Value;
					this->OutTrans[math::index_c(ox + uMAX(1), oy, d, WIDTH_OUT, HEIGHT_OUT)] = Value;
					this->OutTrans[math::index_c(ox, oy + uMAX(1), d, WIDTH_OUT, HEIGHT_OUT)] = Value;
					this->OutTrans[math::index_c(ox + uMAX(1), oy + uMAX(1), d, WIDTH_OUT, HEIGHT_OUT)] = Value;
				}

				ox += uMAX(2); if(ox >= WIDTH_OUT) { ox = uMAX(0); oy += uMAX(2); }
			}}

			SX_MC_LAYER_NEXT_EXE;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			auto ox = uMAX(0);
			auto oy = uMAX(0);
				
			for(auto iy = uMAX(0); iy < HEIGHT_IN; ++iy) { for(auto ix = uMAX(0); ix < WIDTH_IN; ++ix)
			{
				for(auto d = uMAX(0); d < DEPTH_IN; ++d)
				{
					uMAX o[4];
					o[0] = math::index_c(ox, oy, d, WIDTH_OUT, HEIGHT_OUT);
					o[1] = math::index_c(ox + uMAX(1), oy, d, WIDTH_OUT, HEIGHT_OUT);
					o[2] = math::index_c(ox, oy + uMAX(1), d, WIDTH_OUT, HEIGHT_OUT);
					o[3] = math::index_c(ox + uMAX(1), oy + uMAX(1), d, WIDTH_OUT, HEIGHT_OUT);


					T DerErr[4];
					
					if(this->Front)
					{
						DerErr[0] = this->Front->gradient()[o[0]];
						DerErr[1] = this->Front->gradient()[o[1]];
						DerErr[2] = this->Front->gradient()[o[2]];
						DerErr[3] = this->Front->gradient()[o[3]];
					}
					
					else
					{
						DerErr[0] = errorDer<T,FN_ERR>(_Target[o[0]], this->OutTrans[o[0]]);
						DerErr[1] = errorDer<T,FN_ERR>(_Target[o[1]], this->OutTrans[o[1]]);
						DerErr[2] = errorDer<T,FN_ERR>(_Target[o[2]], this->OutTrans[o[2]]);
						DerErr[3] = errorDer<T,FN_ERR>(_Target[o[3]], this->OutTrans[o[3]]);
					}


					this->Gradient[math::index_c(ix, iy, d, WIDTH_IN, HEIGHT_IN)] = (DerErr[0] + DerErr[1] + DerErr[2] + DerErr[3]);
				}

				ox += uMAX(2); if(ox >= WIDTH_OUT) { ox = uMAX(0); oy += uMAX(2); }
			}}

			SX_MC_LAYER_NEXT_FIT;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get error between target and output.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"
	};
}
