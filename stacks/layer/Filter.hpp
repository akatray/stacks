// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "./../Layer.hpp"

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{

class Nothing
{
};
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Effects options.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	enum class Effect
	{
		NORMALIZE,
		NOISE
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Effect params: Noise.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	struct EPNoise
	{
		const rMAX Min;
		const rMAX Max;

		constexpr EPNoise ( void ) : Min(0.9), Max(1.1) {}
		constexpr EPNoise ( const rMAX _Min, const rMAX _Max ) : Min(_Min), Max(Max) {}
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Effect data: Normalize.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> struct EDNormalize
	{
		alignas(ALIGNMENT) T Mean;
		alignas(ALIGNMENT) T Deviation;

		alignas(ALIGNMENT) T Alpha;
		alignas(ALIGNMENT) T DltAlpha;
		alignas(ALIGNMENT) T DltMAlpha;
		alignas(ALIGNMENT) T DltVAlpha;

		alignas(ALIGNMENT) T Beta;
		alignas(ALIGNMENT) T DltBeta;
		alignas(ALIGNMENT) T DltMBeta;
		alignas(ALIGNMENT) T DltVBeta;

		EDNormalize ( void ) :
			Mean(),
			Deviation(),
			
			Alpha(rng::rnum_nrm<T>()),
			DltAlpha(),
			DltMAlpha(),
			DltVAlpha(),

			Beta(rng::rnum_nrm<T>()),
			DltBeta(),
			DltMBeta(),
			DltVBeta(){}
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Effect data: Noise.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, uMAX SIZE> struct EDNoise
	{
		alignas(ALIGNMENT) T Noise[SIZE];
		EDNoise ( void ) : Noise{} {}
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Apply effect on input data.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		Effect EFFECT,
		uMAX SZ_IN,
		FnOptim FN_OPTIM = FnOptim::MOMENTUM,
		class PARAMS = std::conditional_t<EFFECT == Effect::NORMALIZE, Nothing, std::conditional_t<EFFECT == Effect::NOISE, EPNoise, Nothing>>
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Filter :
		public Layer<T>,
		Outputs_ld<T, SZ_IN, SZ_IN, false>,
		std::conditional_t<EFFECT == Effect::NORMALIZE, EDNormalize<T>, Nothing>,
		std::conditional_t<EFFECT == Effect::NOISE, EDNoise<T, SZ_IN>, Nothing>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto SZ_OUT = SZ_IN;

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Members.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		PARAMS Params;

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Filter, SZ_IN, this->OutTrans, this->Gradient)

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Constructors.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Filter ( void ) : Params() {}
		Filter ( const PARAMS& _Params ) : Params(_Params) {}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			if constexpr(EFFECT == Effect::NORMALIZE)
			{
				this->Mean = math::mean(SZ_IN, this->Input);
				this->Deviation = std::sqrt(math::sqr(math::stddev(SZ_IN, this->Input, this->Mean)) + T(1e-5));
				
				for(auto o = uMAX(0); o < SZ_IN; ++o) this->OutTrans[o] = this->Alpha * ((this->Input[o] - this->Mean) / this->Deviation) + this->Beta;
			}

			if constexpr(EFFECT == Effect::NOISE)
			{
				rng::rbuf<T>(SZ_IN, this->Noise, this->Params.Min, this->Params.Max);
				vops::mulVecByVec(SZ_IN, this->OutTrans, this->Input, this->Noise);
			}
			
			SX_MC_LAYER_NEXT_EXE;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			for(auto o = uMAX(0); o < SZ_IN; ++o)
			{
				//SX_MC_LAYER_DER_ERR;

				if constexpr(EFFECT == Effect::NORMALIZE)
				{
					this->DltAlpha += ((this->Input[o] - this->Mean) / this->Deviation) * DerErr;
					this->DltBeta += DerErr;
					
					DerErr *= this->Alpha / this->Deviation;
					
					this->Gradient[o] = DerErr;
				}

				if constexpr(EFFECT == Effect::NOISE)
				{
					this->Gradient[o] = this->Noise[o] * DerErr;
				}
			}
		
			SX_MC_LAYER_NEXT_FIT;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get output error in respect to argument.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Reset delta parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_RESET final
		{
			if(!this->IsLocked)
			{
				if constexpr(EFFECT == Effect::NORMALIZE)
				{
					this->DltAlpha = T(0);
					this->DltBeta = T(0);
				}
			}

			SX_MC_LAYER_NEXT_RESET;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply optimizations and update parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_APPLY final
		{
			if(!this->IsLocked)
			{
				if constexpr(EFFECT == Effect::NORMALIZE)
				{
					optimApply<T,FN_OPTIM>(_Rate, _Iter, 1, &this->Alpha, &this->DltAlpha, &this->DltMAlpha, &this->DltVAlpha);
					optimApply<T,FN_OPTIM>(_Rate, _Iter, 1, &this->Beta, &this->DltBeta, &this->DltMBeta, &this->DltVBeta);
				}
			}

			SX_MC_LAYER_NEXT_APPLY;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Store parameters to stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_STORE final
		{
			if constexpr(EFFECT == Effect::NORMALIZE)
			{
				_Stream.write(reinterpret_cast<const char*>(&this->Alpha), sizeof(T));
				_Stream.write(reinterpret_cast<const char*>(&this->Beta), sizeof(T));
			}
			
			SX_MC_LAYER_NEXT_STORE;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Load parameters from stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_LOAD final
		{
			if constexpr(EFFECT == Effect::NORMALIZE)
			{
				_Stream.read(reinterpret_cast<char*>(&this->Alpha), sizeof(T));
				_Stream.read(reinterpret_cast<char*>(&this->Beta), sizeof(T));
			}

			SX_MC_LAYER_NEXT_LOAD;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Multi threading utility.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXCHANGE final
		{
			auto Master = static_cast<decltype(this)>(_Master);

			if constexpr(EFFECT == Effect::NORMALIZE)
			{
				Master->DltAlpha = this->DltAlpha;
				Master->DltBeta = this->DltBeta;
				this->Alpha = Master->Alpha;
				this->Beta = Master->Beta;
			}

			if(this->Front && _Chain) this->Front->exchange(Master->Front);
		}
	};
}