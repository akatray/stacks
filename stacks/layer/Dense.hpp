// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Dense layer.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		uMAX SZ_IN,
		uMAX SZ_OUT,
		class FN_TRANS,
		FnOptim FN_OPTIM = FnOptim::ADAM
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class Dense :
		public Layer<T>,
		LDOutputs<T, SZ_OUT, SZ_IN, FnTrans::RELU>,
		LDWeights<T, FN_OPTIM, SZ_IN*SZ_OUT, SZ_IN, SZ_OUT, FnInitWeights::NRM_RELU>,
		LDBiases<T, SZ_OUT, SZ_IN, SZ_OUT, FN_OPTIM>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Compile time constants.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		constexpr static auto SZ_BUF_W = SZ_OUT * SZ_IN;
		constexpr static auto SZ_BUF_B = SZ_OUT;
		

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Generated functions.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_MC_LAYER_TRIVIAL(Dense, SZ_OUT, this->OutTrans, this->Gradient)


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Execute.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_EXE final
		{
			for(auto o = uMAX(0); o < SZ_OUT; ++o)
			{
				if constexpr(FN_TRANS::RAW)
				{
					this->OutRaw[o] = std::inner_product(this->Input, this->Input + SZ_IN, this->Weights + math::index_c(0, o, SZ_IN), T(0)) + this->Biases[o];
					this->OutTrans[o] = FN_TRANS::trans(this->OutRaw[o]);
				}

				else
				{
					this->OutTrans[o] =  FN_TRANS::trans(std::inner_product(this->Input, this->Input + SZ_IN, this->Weights + math::index_c(0, o, SZ_IN), T(0)) + this->Biases[o]);
				}
			}

			SX_MC_LAYER_NEXT_EXE;
		}


		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Backpropagate.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		SX_FNSIG_LAYER_FIT final
		{
			memZero(SZ_IN, this->Gradient);

			auto OutNeeded = this->OutTrans;
			if constexpr(FN_TRANS::RAW) OutNeeded = this->OutRaw;
			
			if(!this->IsLocked)
			{
				for(auto o = uMAX(0); o < SZ_OUT; ++o)
				{
					const auto DerErr = this->Front->gradient()[o];
					const auto DerTrans = std::clamp(FN_TRANS::der(OutNeeded[o]) * DerErr, T(-1), T(1));

					vops::mulVecByConstAddToOut(SZ_IN, this->Gradient, &this->Weights[math::index_c(0, o, SZ_IN)], DerTrans);
					vops::mulVecByConstAddToOut(SZ_IN, &this->WeightsDlt[math::index_c(0, o, SZ_IN)], this->Input, DerTrans);
					this->BiasesDlt[o] += DerTrans;
				}
			}

			else
			{
				for(auto o = uMAX(0); o < SZ_OUT; ++o)
				{
					const auto DerErr = this->Front->gradient()[o];
					const auto DerTrans = std::clamp(FN_TRANS::der(OutNeeded[o]) * DerErr, T(-1), T(1));

					vops::mulVecByConstAddToOut(SZ_IN, this->Gradient, &this->Weights[math::index_c(0, o, SZ_IN)], DerTrans);
				}
			}
			
			SX_MC_LAYER_NEXT_FIT;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get output error in respect to argument.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplErr.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Reset delta parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplReset.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply optimizations and update parameters.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplApply.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Store parameters to stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplStore.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Load parameters from stream.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplLoad.hpp"

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Multi threading utility.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		#include "./data/ComImplExchange.hpp"
	};
}
