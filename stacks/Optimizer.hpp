// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Constants.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr auto BETA1 = r64(0.9);
	constexpr auto BETA1F = r64(1.0) - BETA1;
	constexpr auto BETA2 = r64(0.99999999);
	constexpr auto BETA2F = r64(1.0) - BETA2;
	constexpr auto EPSILON = r64(1e-8);


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Optimizer options.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	enum class FnOptim
	{
		NONE,
		MOMENTUM,
		ADAM
	};


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Does optimizer need m buffer.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnOptim FN_OPTIM> constexpr inline auto needBufM ( void )
	{
		if constexpr((FN_OPTIM == FnOptim::MOMENTUM) || (FN_OPTIM == FnOptim::ADAM)) return true;
		else return false;
	}


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Does optimizer need v buffer.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnOptim FN_OPTIM> constexpr inline auto needBufV ( void )
	{
		if constexpr(FN_OPTIM == FnOptim::ADAM) return true;
		else return false;
	}


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Optimized apply.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template
	<
		class T,
		FnOptim FN_OPTIM
	>
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	auto optimApply
	(
		const T _Rate,
		const uMAX _Iter,
		
		const u64 _Size,
		T* _Buff,
		T* _BuffD,
		T* _BuffM,
		T* _BuffV

	)
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	{
		if constexpr(FN_OPTIM == FnOptim::NONE)
		{
			for(auto i = uMAX(0); i < _Size; ++i)
			{
				_Buff[i] -= _BuffD[i] * _Rate;
			}
		}
		

		if constexpr(FN_OPTIM == FnOptim::MOMENTUM)
		{
			for(auto i = uMAX(0); i < _Size; ++i)
			{
				_BuffM[i] = (_BuffD[i] * BETA1F) + (_BuffM[i] * BETA1);
				_Buff[i] -= _Rate * _BuffM[i];
			}
		}


		if constexpr(FN_OPTIM == FnOptim::ADAM)
		{
			const auto Iter = _Iter + 1;
			
			for(auto i = uMAX(0); i < _Size; ++i)
			{
				_BuffM[i] = (BETA1 * _BuffM[i]) + (BETA1F * _BuffD[i]);
				_BuffV[i] = (BETA2 * _BuffV[i]) + (BETA2F * math::sqr(_BuffD[i]));
				
				const auto m = _BuffM[i] / (T(1) - std::pow(BETA1, Iter));
				const auto v = _BuffV[i] / (T(1) - std::pow(BETA2, Iter));

				_Buff[i] -= (_Rate * m) / (std::sqrt(v) + EPSILON);
			}
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
}
