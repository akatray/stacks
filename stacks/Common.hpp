// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <cstdint>
#include <cstring>
#include <string>
#include <vector>
#include <type_traits>
#include <functional>
#include <numeric>

namespace ai
{
	template<class T> using vec = std::vector<T>;

}



// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	#define SX_META template<class T = r32>
	
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Type renaming.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using ptr = void*;
	
	using u8 = std::uint8_t;
	using u16 = std::uint16_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;
	using uMAX = std::uint64_t;

	using i8 = std::int8_t;
	using i16 = std::int16_t;
	using i32 = std::int32_t;
	using i64 = std::int64_t;
	using iMAX = std::int64_t;  // Max unsigned integer.

	using r32 = float;
	using r64 = double;
	using rMAX = long double; // Max real integer.

	using str = std::string;
	template<class T> using vec = std::vector<T>;

	using namespace std::string_literals;

	template<class T = r32> using Samples = vec<vec<T>>;

	template<class T> using fn = std::function<T>;

	


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> auto memZero ( const uMAX _Size, T* _Dst ) { std::memset(_Dst, 0, _Size * sizeof(T)); }
	template<class T> auto memCopy ( const uMAX _Size, T* _Dst, const T* _Src ) { std::memcpy(_Dst, _Src, _Size * sizeof(T)); }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, uMAX LENGHT, uMAX ALIGNMENT = uMAX(64)> struct alignas(ALIGNMENT) cache
	{
		T Data[LENGHT];
		constexpr inline auto operator[] ( const uMAX _Index ) -> T& { return this->Data[_Index]; }
		constexpr inline auto operator() ( void ) -> T* { return this->Data; }
	};
}
