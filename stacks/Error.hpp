// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once


// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Error function options.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	enum class FnErr
	{
		MSE, // Mean square error.
		MAE, // Mean absolute error.
		BCE // Binary cross entropy.
	};


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Calculate error.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnErr FN_ERR> constexpr inline auto error ( const uMAX _Size, const T* _Real, const T* _Predicted )
	{
		if constexpr(FN_ERR == FnErr::MSE)
		{
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&](  T _P, T _R ) { return math::sqr(_P - _R); }
			) / _Size;
		}


		if constexpr(FN_ERR == FnErr::MAE)
		{
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&]( T _P, T _R ) { return std::abs(_P - _R); }
			) / _Size;
		}


		if constexpr(FN_ERR == FnErr::BCE)
		{
			constexpr auto Eps = T(1e-15);
			
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&]( T _P, T _R )
				{
					const auto P = std::clamp(_P, Eps, T(1));
					return (_R * std::log(P) + (T(1) - _R) * std::log((T(1) - P) + Eps));
				}
			) / _Size * -1;
		}
	}


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Error derivitive.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnErr FN_ERR> constexpr inline auto errorDer ( const T _Real, const T _Predicted )
	{
		if constexpr(FN_ERR == FnErr::MSE) return (_Predicted - _Real) * T(2);
		if constexpr(FN_ERR == FnErr::MAE) return (_Predicted - _Real) / std::max(std::abs(_Predicted - _Real), T(1e-15));
		/*
		if constexpr(FN_ERR == FnErr::MAE)
		{
			auto E = _Predicted - _Real;
			
			if(std::signbit(E))
			{
				if(E < -0.5) return -4.0;
				if(E < -0.25) return -1.0;
				if(E < -0.1) return -0.5;
				if(E < -0.01) return -0.01;
				
			}
			else
			{
				if(E > 0.5) return 4.0;
				if(E > 0.25) return 1.0;
				if(E > 0.1) return 0.5;
				if(E > 0.01) return 0.01;
				
				
			}
			*/
			

			
			


		//return (_Predicted - _Real) * (_Predicted - _Real) * (_Predicted - _Real);
		//}
		if constexpr(FN_ERR == FnErr::BCE) return (_Predicted - _Real) / std::max((T(1) - _Predicted) * _Predicted, T(1e-15));
	}
}
