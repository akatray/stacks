// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Neural Networks Experiment.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace sx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Expand namespaces.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using namespace fx;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Error function options.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	enum class FnErr
	{
		MSE, // Mean square error.
		MAE, // Mean absolute error.
		BCE // Binary cross entropy.
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Calculate error.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnErr FN_ERR> constexpr inline auto error ( const uMAX _Size, const T* _Real, const T* _Predicted )
	{
		if constexpr(FN_ERR == FnErr::MSE)
		{
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&](  T _P, T _R ) { return math::sqr(_P - _R); }
			) / _Size;
		}

		if constexpr(FN_ERR == FnErr::MAE)
		{
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&]( T _P, T _R ) { return std::abs(_P - _R); }
			) / _Size;
		}

		if constexpr(FN_ERR == FnErr::BCE)
		{
			constexpr auto Eps = T(1e-15);
			
			return std::transform_reduce
			(
				_Predicted,
				_Predicted + _Size,
				_Real,
				T(0),
				[&]( T _Sum, T _Item ) { return _Sum + _Item; },
				[&]( T _P, T _R )
				{
					const auto P = std::clamp(_P, Eps, T(1));
					return (_R * std::log(P) + (T(1) - _R) * std::log((T(1) - P) + Eps));
				}
			) / _Size * -1;
		}
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Error derivitive.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, FnErr FN_ERR> constexpr inline auto errorDer (const T _Real, const T _Predicted)
	{
		if constexpr(FN_ERR == FnErr::MSE) return (_Predicted - _Real) * T(2);
		if constexpr(FN_ERR == FnErr::MAE) return (_Predicted - _Real) / std::abs(_Predicted - _Real);
		if constexpr(FN_ERR == FnErr::BCE) return (_Predicted - _Real) / std::max((T(1) - _Predicted) * _Predicted, T(1e-15));
	}
}
